两个变量同增同减；协方差越大说明X与Y关系越紧密；而相关系数是协方差的标准化。

![](https://cdn.nlark.com/yuque/__latex/78bdeac998c37266efd19a2704f8a601.svg)

![](https://cdn.nlark.com/yuque/__latex/e141a6514240c2584974db840659b809.svg)

## 协方差和相关系数思想

信用卡用户的学历（X）和其还款能力（Y）的关系，可以计算所有用户学历X减去学历平均值![](https://cdn.nlark.com/yuque/__latex/1e3b2bbbe4a504c014cfdfbab07d6486.svg)再乘以其还款能力Y减去还款能力平均值![](https://cdn.nlark.com/yuque/__latex/f7fc9a6ea9af7e9e806ef13514c410a2.svg)之和，再除以用户数目。

思想：如果两者是同增同减那么![](https://cdn.nlark.com/yuque/__latex/c72cff2f9c3d94a1ecfc31cf2618af44.svg)为正值，反之为负值。

## 例题

将一枚硬币重复掷n次，以X和Y分别表示正面向上和反面向上的次数，则X和Y的相  
关系数等于（ -1 ）

因为：X和Y是绝对的你增我减关系。

## R中计算协方差

默认列是变量

```
m = matrix(c(0.3148,  0.0478,  0.6243,  0.4608,
  0.7149,  0.0775,  0.6072,  0.9656,
  0.6341,  0.1403,  0.9759,  0.4064,
  0.5918,  0.6948,  0.904 ,  0.3721,
  0.0921,  0.2481,  0.1188,  0.1366)
  ,ncol=4,byrow=T)
cov(m)
# 0.067158613  0.006502495  0.06966392  0.05660681
# 0.006502495  0.070045345  0.02266311  -0.02990921
# 0.069663921  0.022663113  0.11382854  0.02762483
# 0.056606812  -0.029909212  0.02762483  0.09261862
```

## Python中计算协方差

`rowvar=False` 列是变量

```
import numpy as np
m = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
              [ 0.7149,  0.0775,  0.6072,  0.9656],
              [ 0.6341,  0.1403,  0.9759,  0.4064],
              [ 0.5918,  0.6948,  0.904 ,  0.3721],
              [ 0.0921,  0.2481,  0.1188,  0.1366]])
np.cov(m,rowvar=False)
# array([[ 0.06715861,  0.0065025 ,  0.06966392,  0.05660681],
#        [ 0.0065025 ,  0.07004534,  0.02266311, -0.02990921],
#        [ 0.06966392,  0.02266311,  0.11382854,  0.02762483],
#        [ 0.05660681, -0.02990921,  0.02762483,  0.09261862]])
```

## Julia中计算协方差

默认列是变量

```
using StatsBase
m = [0.3148  0.0478 0.6243 0.4608
  0.7149 0.0775 0.6072 0.9656
  0.6341 0.1403 0.9759 0.4064
  0.5918 0.6948 0.904 0.3721
  0.0921 0.2481 0.1188 0.1366]
cov(m)
# 4×4 Matrix{Float64}:
#  0.0671586   0.0065025  0.0696639   0.0566068
#  0.0065025   0.0700453  0.0226631  -0.0299092
#  0.0696639   0.0226631  0.113829    0.0276248
#  0.0566068  -0.0299092  0.0276248   0.0926186
```

## R中计算相关系数

默认是pearson相关性检验

```
v1=m[:,1]
v2=m[:,2]
cor.test(v1,v2,method="spearman")
# Spearman's rank correlation rho

# data:  m[, 1] and m[, 2]
# S = 24, p-value = 0.7833
# alternative hypothesis: true rho is not equal to 0
# sample estimates:
#  rho 
# -0.2 
```

## Python中计算相关系数

### Pearson’s Correlation Coefficient

v1,v2符合正态分布

```
import scipy.stats as spss
v1,v2=m[:,0],m[:,1]
r, p_value = spss.pearsonr(v1,v2)
```

### spearman

v1,v2的分布没有特定的要求

```
r, p_value = spss.spearmanr(v1,v2)
```

### kendalltau

v1,v2的分布没有特定的要求

```
r, p_value = spss.kendalltau(v1,v2)
```

### 自定义函数

因为scipy计算相关性系数要去v1和v2不能有缺失值，所以自定义一个函数去掉缺失值，还支持 3 种相关系数计算

用法

```
r, p_value = cor(v1,v2,method = "spearman", pvalue=True)
```

函数

```
def cor(a,b,method = "pearson",min_periods=1,pvalue=True):
    if len(a) != len(b):
        raise AssertionError("Operands to nancorr must have same size")

    valid = pd.notna(a) & pd.notna(b)
    if not valid.all():
        a = a[valid]
        b = b[valid]

    if len(a) < min_periods:
        return (np.nan, np.nan) if pvalue else np.nan
    f = get_corr_func(method)

    return f(a, b) if pvalue else f(a, b)[0]

def get_corr_func(method="pearson"):
    if method == "kendall":
        from scipy.stats import kendalltau

        def func(a, b):
            return kendalltau(a, b)

        return func
    elif method == "spearman":
        from scipy.stats import spearmanr

        def func(a, b):
            return spearmanr(a, b)

        return func
    elif method == "pearson":
        from scipy.stats import pearsonr
        def func(a, b):
            return pearsonr(a, b)

        return func
    elif callable(method):
        return method

    raise ValueError(
        f"Unknown method '{method}', expected one of "
        "'kendall', 'spearman', 'pearson', or callable"
    )
```

## Julia中计算相关系数

### Spearman's rank correlation

```
import StatsBase
v1,v2=m[:,1],m[:,2]
StatsBase.corspearman(v1,v2) == -0.2
```

### Pearson's product-moment correlation

```
import Statistics, StatsBase,HypothesisTests
Statistics.cor(v1,v2) == 0.0948068087989786 # correlation 
StatsBase.cor(v1,v2) == 0.0948068087989786 # correlation

HypothesisTests.CorrelationTest(v1,v2)
# Test for nonzero correlation
#     ----------------------------
#     Population details:
#         parameter of interest:   Correlation
#         value under h_0:         0.0
#         point estimate:          0.0948068
#         95% confidence interval: (-0.8593, 0.9017)
    
#     Test summary:
#         outcome with 95% confidence: fail to reject h_0
#         two-sided p-value:           0.8795
    
#     Details:
#         number of observations:          5
#         number of conditional variables: 0
#         t-statistic:                     0.164953
#         degrees of freedom:              3
```

### kendalltau

```
StatsBase.corkendall(v1,v2) == -0.2
```